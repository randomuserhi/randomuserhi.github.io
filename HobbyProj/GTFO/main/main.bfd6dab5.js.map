{"mappings":"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","sources":["src/HobbyProj/GTFO/main/graph.js"],"sourcesContent":["RHU.import(RHU.module({ trace: new Error(),\n    name: \"Report\", hard: [\"RHU.Macro\", \"RHU.Rest\"],\n    callback: function () {\n        let { RHU } = window.RHU.require(window, this);\n        let GTFOIcons = new Map();\n        if (true) {\n            let img = new Image();\n            img.src = \"./icons/general/checkpoint.png\";\n            GTFOIcons.set(\"checkpoint\", img);\n        }\n        let graph = function () {\n            this.GTFOEnemyIcons = new Map();\n            this.GTFOGearIcons = new Map();\n            this.GTFOPackIcons = new Map();\n            this.camera = {\n                zoom: 1,\n                x: 0,\n                y: 0\n            };\n            this.selected = null;\n            this.selectedEvents = [];\n            this.timeline.addEventListener(\"contextmenu\", (e) => {\n                e.preventDefault();\n                e.stopPropagation();\n            });\n            this.ctx = this.timeline.getContext(\"2d\");\n            window.addEventListener(\"resize\", () => {\n                this.render();\n            });\n            this.render();\n            this.mouse = {\n                left: false,\n                right: false,\n                x: 0,\n                y: 0\n            };\n            let origin = { x: 0, y: 0 };\n            let old = { x: 0, y: 0 };\n            this.timeline.addEventListener(\"mousedown\", (e) => {\n                e.preventDefault();\n                if (e.button === 0) {\n                    this.mouse.left = true;\n                }\n                else if (e.button === 2) {\n                    let time = (this.mouse.x + this.camera.x - this.timeline.width / 2) * this.timePerPixel;\n                    this.selected = { start: time, end: time };\n                    this.mouse.right = true;\n                }\n                old.x = this.mouse.x;\n                old.y = this.mouse.y;\n                origin.x = this.mouse.x;\n                origin.y = this.mouse.y;\n            });\n            this.timeline.addEventListener(\"mousemove\", (e) => {\n                e.preventDefault();\n                let rect = this.timeline.getBoundingClientRect();\n                this.mouse.x = e.clientX - rect.left;\n                this.mouse.y = e.clientY - rect.top;\n                if (this.mouse.left) {\n                    this.camera.x += old.x - this.mouse.x;\n                    old.x = this.mouse.x;\n                }\n                else if (this.mouse.right) {\n                    if (RHU.exists(this.selected)) {\n                        let time = (this.mouse.x + this.camera.x - this.timeline.width / 2) * this.timePerPixel;\n                        this.selected.end = time;\n                    }\n                }\n                this.render();\n            });\n            this.timeline.addEventListener(\"mouseup\", (e) => {\n                e.preventDefault();\n                if (e.button === 0) {\n                    this.mouse.left = false;\n                    if (this.mouse.x === origin.x && this.mouse.y === origin.y) {\n                        this.selected = null;\n                        this.render();\n                    }\n                }\n                else if (e.button === 2) {\n                    this.mouse.right = false;\n                    if (this.mouse.x === origin.x && this.mouse.y === origin.y) {\n                        this.selected = null;\n                        this.render();\n                    }\n                }\n            });\n            this.timeline.addEventListener(\"wheel\", (e) => {\n                if (this.mouse.y > this.timeline.height / 2 - 100 &&\n                    this.mouse.y < this.timeline.height / 2 + 100) {\n                    e.preventDefault();\n                    let zoom = this.camera.zoom;\n                    this.camera.zoom -= e.deltaY * 0.002;\n                    if (this.camera.zoom < 0.01)\n                        this.camera.zoom = 0.01;\n                    let old = this.mouse.x + this.camera.x - this.timeline.width / 2;\n                    let delta = old / zoom * this.camera.zoom;\n                    this.camera.x += delta - old;\n                    this.render();\n                }\n            });\n        };\n        graph.prototype.render = function () {\n            let computed = getComputedStyle(this.timeline);\n            this.timeline.width = parseInt(computed.width);\n            this.timeline.height = parseInt(computed.height);\n            if (this.timeline.width === 0)\n                return;\n            let w = this.timeline.width;\n            let h = this.timeline.height;\n            let ctx = this.ctx;\n            ctx.clearRect(0, 0, w, h);\n            if (RHU.exists(this.player) && RHU.exists(this.report)) {\n                const maximum = 100;\n                const snapshotSize = 10 * 60 * 1000 / this.camera.zoom;\n                const gridSize = 1;\n                this.timePerPixel = snapshotSize / w;\n                const timePerGrid = this.timePerPixel * gridSize;\n                const start = Math.floor((this.camera.x - w / 2) / gridSize) * timePerGrid;\n                const end = Math.ceil((this.camera.x + w / 2) / gridSize) * timePerGrid;\n                ctx.beginPath();\n                ctx.moveTo(0, h / 2 + maximum);\n                ctx.lineTo(w, h / 2 + maximum);\n                ctx.lineWidth = 1;\n                ctx.strokeStyle = \"#dadad1\";\n                ctx.stroke();\n                ctx.beginPath();\n                ctx.moveTo(0, h / 2 - maximum);\n                ctx.lineTo(w, h / 2 - maximum);\n                ctx.lineWidth = 1;\n                ctx.strokeStyle = \"#dadad1\";\n                ctx.stroke();\n                ctx.translate(0, h / 2);\n                ctx.save();\n                ctx.translate(w / 2, 0);\n                let health = this.player.healthMax;\n                let infection = 0;\n                if (true) {\n                    let timeline = this.player.healthTimeline;\n                    let index = 0;\n                    for (; index < timeline.length; ++index) {\n                        if (timeline[index].timestamp > start) {\n                            if (index > 0)\n                                --index;\n                            break;\n                        }\n                    }\n                    let event = timeline[index];\n                    let percentage = event.value / this.player.healthMax;\n                    let x = (Math.round(event.timestamp / timePerGrid) * timePerGrid / this.timePerPixel) - this.camera.x;\n                    if (x < this.mouse.x - w / 2)\n                        health = event.value;\n                    ctx.beginPath();\n                    let y = maximum - 2 * maximum * percentage;\n                    ctx.moveTo(x, y);\n                    ++index;\n                    for (; index < timeline.length; ++index) {\n                        let event = timeline[index];\n                        let percentage = event.value / this.player.healthMax;\n                        let x = (Math.round(event.timestamp / timePerGrid) * timePerGrid / this.timePerPixel) - this.camera.x;\n                        if (x < this.mouse.x - w / 2)\n                            health = event.value;\n                        ctx.lineTo(x, y);\n                        y = maximum - 2 * maximum * percentage;\n                        ctx.lineTo(x, y);\n                        if (timeline[index].timestamp > end)\n                            break;\n                    }\n                    ctx.lineWidth = 1;\n                    ctx.strokeStyle = \"red\";\n                    ctx.stroke();\n                }\n                if (this.player.infectionTimeline.filter((i) => i.value != 0).length > 0) {\n                    let timeline = this.player.infectionTimeline;\n                    let index = 0;\n                    for (; index < timeline.length; ++index) {\n                        if (timeline[index].timestamp > start) {\n                            if (index > 0)\n                                --index;\n                            break;\n                        }\n                    }\n                    let event = timeline[index];\n                    let percentage = 1 - event.value;\n                    let x = (Math.round(event.timestamp / timePerGrid) * timePerGrid / this.timePerPixel) - this.camera.x;\n                    if (x < this.mouse.x - w / 2)\n                        infection = event.value;\n                    ctx.beginPath();\n                    let y = maximum - 2 * maximum * percentage;\n                    ctx.moveTo(x, y);\n                    ++index;\n                    for (; index < timeline.length; ++index) {\n                        let event = timeline[index];\n                        let percentage = 1 - event.value;\n                        let x = (Math.round(event.timestamp / timePerGrid) * timePerGrid / this.timePerPixel) - this.camera.x;\n                        if (x < this.mouse.x - w / 2)\n                            infection = event.value;\n                        ctx.lineTo(x, y);\n                        y = maximum - 2 * maximum * percentage;\n                        ctx.lineTo(x, y);\n                        if (timeline[index].timestamp > end)\n                            break;\n                    }\n                    ctx.lineWidth = 1;\n                    ctx.strokeStyle = \"green\";\n                    ctx.stroke();\n                }\n                if (true) {\n                    let timeline = this.player.stateTimeline;\n                    let index = 0;\n                    for (; index < timeline.length; ++index) {\n                        if (timeline[index].timestamp > start) {\n                            if (index > 0)\n                                --index;\n                            break;\n                        }\n                    }\n                    for (; index < timeline.length; ++index) {\n                        let event = timeline[index];\n                        let x = (Math.round(event.timestamp / timePerGrid) * timePerGrid / this.timePerPixel) - this.camera.x;\n                        if (event.type !== \"Checkpoint\") {\n                            ctx.beginPath();\n                            ctx.moveTo(x, -maximum - 20);\n                            ctx.lineTo(x, maximum + 20);\n                            ctx.lineWidth = 1;\n                            ctx.strokeStyle = \"rgba(233, 188, 41, 1)\";\n                            ctx.stroke();\n                        }\n                        else {\n                            ctx.beginPath();\n                            ctx.moveTo(x, -maximum - 20);\n                            ctx.lineTo(x, maximum + 20);\n                            ctx.lineWidth = 1;\n                            ctx.strokeStyle = \"rgba(80, 212, 120, 0.5)\";\n                            ctx.stroke();\n                            if (GTFOIcons.has(\"checkpoint\")) {\n                                ctx.drawImage(GTFOIcons.get(\"checkpoint\"), x - 25, -maximum - 150, 50, 50);\n                            }\n                        }\n                        if (timeline[index].timestamp > end)\n                            break;\n                    }\n                }\n                if (true) {\n                    let timeline = this.player.damageTimeline;\n                    let index = 0;\n                    for (; index < timeline.length; ++index) {\n                        if (timeline[index].timestamp > start) {\n                            if (index > 0)\n                                --index;\n                            break;\n                        }\n                    }\n                    for (; index < timeline.length; ++index) {\n                        let event = timeline[index];\n                        let x = (Math.round(event.timestamp / timePerGrid) * timePerGrid / this.timePerPixel) - this.camera.x;\n                        ctx.beginPath();\n                        ctx.moveTo(x, -maximum - 20);\n                        ctx.lineTo(x, maximum + 20);\n                        ctx.lineWidth = 1;\n                        ctx.strokeStyle = \"rgba(218, 218, 216, 0.3)\";\n                        ctx.stroke();\n                        if (RHU.exists(event.enemyInstanceID)) {\n                            let enemy = this.report.enemies.get(event.enemyInstanceID);\n                            if (RHU.exists(enemy) && this.GTFOEnemyIcons.has(enemy.type)) {\n                                ctx.drawImage(this.GTFOEnemyIcons.get(enemy.type), x - 25, maximum + 80, 50, 50);\n                            }\n                        }\n                        else if (RHU.exists(event.playerID) && RHU.exists(event.gearName)) {\n                            if (this.GTFOGearIcons.has(event.gearName)) {\n                                ctx.drawImage(this.GTFOGearIcons.get(event.gearName), x - 25, maximum + 80, 50, 50);\n                            }\n                        }\n                        if (timeline[index].timestamp > end)\n                            break;\n                    }\n                }\n                if (true) {\n                    let timeline = this.player.packsTimeline;\n                    let index = 0;\n                    for (; index < timeline.length; ++index) {\n                        if (timeline[index].timestamp > start) {\n                            if (index > 0)\n                                --index;\n                            break;\n                        }\n                    }\n                    for (; index < timeline.length; ++index) {\n                        let event = timeline[index];\n                        let x = (Math.round(event.timestamp / timePerGrid) * timePerGrid / this.timePerPixel) - this.camera.x;\n                        ctx.beginPath();\n                        ctx.moveTo(x, -maximum - 20);\n                        ctx.lineTo(x, maximum + 20);\n                        ctx.lineWidth = 1;\n                        ctx.strokeStyle = \"rgba(233, 188, 41, 0.5)\";\n                        ctx.stroke();\n                        if (this.GTFOPackIcons.has(event.type)) {\n                            ctx.drawImage(this.GTFOPackIcons.get(event.type), x - 25, -maximum - 150, 50, 50);\n                        }\n                        if (timeline[index].timestamp > end)\n                            break;\n                    }\n                }\n                if (RHU.exists(this.selected)) {\n                    let x1 = (this.selected.start / this.timePerPixel) - this.camera.x;\n                    let x2 = (this.selected.end / this.timePerPixel) - this.camera.x;\n                    if (x1 > x2) {\n                        let temp = x1;\n                        x1 = x2;\n                        x2 = temp;\n                    }\n                    ctx.fillStyle = \"rgba(218, 218, 216, 0.3)\";\n                    ctx.fillRect(x1, -maximum, x2 - x1, maximum * 2);\n                }\n                ctx.restore();\n                ctx.beginPath();\n                ctx.moveTo(this.mouse.x, -maximum - 20);\n                ctx.lineTo(this.mouse.x, maximum + 20);\n                ctx.lineWidth = 1;\n                ctx.strokeStyle = \"#dadad1\";\n                ctx.stroke();\n                ctx.font = \"20px Oxanium\";\n                let text = `${Math.round(health / this.player.healthMax * 100)}`;\n                let metrics = ctx.measureText(text);\n                ctx.fillStyle = \"#dadad1\";\n                ctx.fillText(text, this.mouse.x - metrics.width / 2, -maximum - 40);\n                let time = (this.mouse.x + this.camera.x - w / 2) * this.timePerPixel;\n                if (time > 0) {\n                    ctx.font = \"20px Oxanium\";\n                    let seconds = Math.floor(time / 1000);\n                    let minutes = Math.floor(seconds / 60);\n                    let hours = Math.floor(minutes / 60);\n                    let s = seconds - minutes * 60;\n                    let m = minutes - hours * 60;\n                    if (hours > 0)\n                        text = `${hours.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;\n                    else\n                        text = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;\n                    metrics = ctx.measureText(text);\n                    ctx.fillStyle = \"#dadad1\";\n                    ctx.fillText(text, this.mouse.x - metrics.width / 2, maximum + 60);\n                }\n                if (infection != 0) {\n                    ctx.font = \"20px Oxanium\";\n                    text = `${Math.round(infection * 100)}`;\n                    metrics = ctx.measureText(text);\n                    ctx.fillStyle = \"green\";\n                    ctx.fillText(text, this.mouse.x - metrics.width / 2, -maximum - 60);\n                }\n            }\n            if (RHU.exists(this.selected) && RHU.exists(this.player)) {\n                let selectedEvents = [];\n                let timeline = this.player.timeline;\n                let start = this.selected.start;\n                let end = this.selected.end;\n                let i = 0;\n                let doUpdate = false;\n                if (start > end) {\n                    let temp = start;\n                    start = end;\n                    end = temp;\n                }\n                let index = 0;\n                for (; index < timeline.length; ++index) {\n                    if (timeline[index].event.timestamp > start)\n                        break;\n                }\n                for (; index < timeline.length; ++index) {\n                    if (timeline[index].event.timestamp > end)\n                        break;\n                    selectedEvents.push(timeline[index]);\n                    if (timeline[index] !== this.selectedEvents[i++])\n                        doUpdate = true;\n                }\n                if (doUpdate || selectedEvents.length !== this.selectedEvents.length) {\n                    this.selectedEvents = selectedEvents;\n                    this.updateSnapshot(this.selectedEvents);\n                }\n            }\n            else\n                this.updateSnapshot();\n        };\n        graph.prototype.updateSnapshot = function (timeline) {\n            this.snapshot.replaceChildren();\n            if (!RHU.exists(timeline))\n                return;\n            if (!RHU.exists(this.report))\n                return;\n            if (!RHU.exists(this.player))\n                return;\n            if (!RHU.exists(this.selected))\n                return;\n            let report = this.report;\n            let self = this.player;\n            let fragment = new DocumentFragment();\n            if (true) {\n                let item;\n                let time;\n                let value;\n                let lastEvent;\n                const timeMergeWindow = 1 * 1000;\n                let reset = () => {\n                    item = document.createElement(\"li\");\n                    item.style.display = `flex`;\n                    item.style.gap = `1rem`;\n                    item.style.alignItems = `center`;\n                    time = document.createElement(\"span\");\n                    time.style.color = \"#c8ad62\";\n                    value = 0;\n                    lastEvent = undefined;\n                };\n                reset();\n                let closeLastEvent = (wrapper) => {\n                    let closeDamage = (e) => {\n                        let timestr = timeToString(e.timestamp);\n                        if (timestr !== time.innerHTML)\n                            time.innerHTML += ` - ${timestr}:`;\n                        else\n                            time.innerHTML += `:`;\n                        let img = document.createElement(\"img\");\n                        img.style.width = `4rem`;\n                        if (RHU.exists(e.enemyInstanceID)) {\n                            img.style.width = `3rem`;\n                            let enemy = report.enemies.get(e.enemyInstanceID);\n                            if (RHU.exists(enemy))\n                                img.src = `./icons/enemies/${enemy.type}.png`;\n                        }\n                        else if (e.type === \"PlayerBullet\" || e.type === \"PlayerExplosive\") {\n                            img.src = `./icons/gear/${e.gearName}.webp`;\n                        }\n                        let content = document.createElement(\"span\");\n                        content.innerHTML = `<span style=\"font-weight: 800;\">${Math.round(value / self.healthMax * 100)}</span> damage dealt by`;\n                        item.append(time, content, img);\n                        if (RHU.exists(e.enemyInstanceID)) {\n                            let enemy = report.enemies.get(e.enemyInstanceID);\n                            if (RHU.exists(enemy)) {\n                                let a = document.createElement(\"a\");\n                                a.innerHTML = `${enemy.name} (${e.type})`;\n                                a.addEventListener(\"click\", () => {\n                                    mount.enemiesBtn.click();\n                                    requestAnimationFrame(() => {\n                                        if (RHU.exists(enemy))\n                                            mount.navbar[1].panel.list.goTo(enemy.name);\n                                    });\n                                });\n                                item.append(a);\n                            }\n                        }\n                        else {\n                            let player = report.allPlayers.get(e.playerID);\n                            if (RHU.exists(player)) {\n                                let name = document.createElement(\"span\");\n                                name.innerHTML = player.name;\n                                name.style.color = \"#e9bc29\";\n                                item.append(name);\n                            }\n                        }\n                        fragment.append(item);\n                        reset();\n                    };\n                    if (RHU.exists(lastEvent)) {\n                        if (RHU.exists(wrapper))\n                            switch (wrapper.type) {\n                                case \"packs\":\n                                    if (true) {\n                                        switch (lastEvent.type) {\n                                            case \"damage\":\n                                                closeDamage(lastEvent.event);\n                                                break;\n                                        }\n                                    }\n                                    break;\n                                case \"state\":\n                                    if (true) {\n                                        switch (lastEvent.type) {\n                                            case \"damage\":\n                                                closeDamage(lastEvent.event);\n                                                break;\n                                        }\n                                    }\n                                    break;\n                                case \"damage\":\n                                    if (true) {\n                                        let e = wrapper.event;\n                                        let last = lastEvent.event;\n                                        if (e.type === \"FallDamage\") {\n                                            closeDamage(last);\n                                        }\n                                        else {\n                                            switch (lastEvent.type) {\n                                                case \"damage\":\n                                                    if (e.type !== last.type || e.timestamp - last.timestamp > timeMergeWindow)\n                                                        closeDamage(last);\n                                                    else if (RHU.exists(e.enemyInstanceID)) {\n                                                        if (e.enemyInstanceID !== last.enemyInstanceID)\n                                                            closeDamage(last);\n                                                    }\n                                                    else {\n                                                        if (e.gearName !== last.gearName || e.playerID !== last.playerID)\n                                                            closeDamage(last);\n                                                    }\n                                                    break;\n                                            }\n                                        }\n                                    }\n                                    break;\n                            }\n                        else {\n                            switch (lastEvent.type) {\n                                case \"damage\":\n                                    closeDamage(lastEvent.event);\n                                    break;\n                            }\n                        }\n                    }\n                };\n                for (let index = 0; index < timeline.length; ++index) {\n                    let doReset = false;\n                    let event = timeline[index];\n                    closeLastEvent(event);\n                    switch (event.type) {\n                        case \"packs\":\n                            if (true) {\n                                let e = event.event;\n                                time.innerHTML = `${timeToString(e.timestamp)}:`;\n                                let img = document.createElement(\"img\");\n                                img.style.width = `4rem`;\n                                img.src = `./icons/packs/${e.type}.webp`;\n                                let content = document.createElement(\"span\");\n                                let text = \"\";\n                                if (RHU.exists(e.playerID) && e.playerID !== self.playerID) {\n                                    let player = report.allPlayers.get(e.playerID);\n                                    if (RHU.exists(player))\n                                        text += `given by <span>${player.name}</span>`;\n                                }\n                                else\n                                    text = \"consumed\";\n                                content.innerHTML = text;\n                                item.append(time, img, content);\n                                fragment.append(item);\n                                doReset = true;\n                            }\n                            break;\n                        case \"state\":\n                            if (true) {\n                                let e = event.event;\n                                time.innerHTML = `${timeToString(e.timestamp)}:`;\n                                let content = document.createElement(\"span\");\n                                switch (e.type) {\n                                    case \"Down\":\n                                        content.innerHTML = `<span style=\"color: #e9bc29;\">${self.name}</span> was <span>downed</span>`;\n                                        break;\n                                    case \"Revive\":\n                                        if (RHU.exists(e.playerID)) {\n                                            let player = report.allPlayers.get(e.playerID);\n                                            if (RHU.exists(player))\n                                                content.innerHTML = `<span style=\"color: #e9bc29;\">${self.name}</span> was <span>revived</span> by <span style=\"color: #e9bc29;\">${player.name}</span>`;\n                                        }\n                                        break;\n                                    case \"Checkpoint\":\n                                        content.innerHTML = `<span style=\"color: rgb(80, 212, 120);\">Checkpoint reloaded</span>`;\n                                        break;\n                                }\n                                item.append(time, content);\n                                fragment.append(item);\n                                doReset = true;\n                            }\n                            break;\n                        case \"damage\":\n                            if (true) {\n                                let e = event.event;\n                                if (!RHU.exists(lastEvent))\n                                    time.innerHTML = `${timeToString(e.timestamp)}`;\n                                value += e.damage;\n                                if (e.type === \"FallDamage\") {\n                                    item.append(time, document.createTextNode(`${Math.round(value / self.healthMax * 100)} fall damage taken`));\n                                    fragment.append(item);\n                                    reset();\n                                }\n                            }\n                            break;\n                    }\n                    lastEvent = event;\n                    if (doReset)\n                        reset();\n                }\n                closeLastEvent();\n            }\n            this.snapshot.append(fragment);\n        };\n        graph.prototype.load = function (player, report) {\n            this.report = report;\n            this.player = player;\n            this.GTFOEnemyIcons.clear();\n            for (let name in report.spec.enemies) {\n                let enemy = report.spec.enemies[name];\n                if (!this.GTFOEnemyIcons.has(enemy.type)) {\n                    let image = new Image();\n                    this.GTFOEnemyIcons.set(enemy.type, image);\n                    image.src = `./icons/enemies/${enemy.type}.png`;\n                }\n            }\n            this.GTFOGearIcons.clear();\n            for (let name in report.spec.gear) {\n                let gear = report.spec.gear[name];\n                if (!this.GTFOGearIcons.has(gear.publicName)) {\n                    let image = new Image();\n                    this.GTFOGearIcons.set(gear.publicName, image);\n                    image.src = `./icons/gear/${gear.publicName}.webp`;\n                }\n            }\n            this.GTFOPackIcons.clear();\n            for (let name in report.spec.packs) {\n                let pack = report.spec.packs[name];\n                if (!this.GTFOPackIcons.has(pack)) {\n                    let image = new Image();\n                    this.GTFOPackIcons.set(pack, image);\n                    image.src = `./icons/packs/${pack}.webp`;\n                }\n            }\n            this.render();\n        };\n        RHU.Macro(graph, \"graph\", `\r\n            <canvas rhu-id=\"timeline\" style=\"width: 100%; height: 70vh;\"></canvas>\r\n            <div class=\"margins\">\r\n                <div class=\"margins-wrapper\">\r\n                    <ul rhu-id=\"snapshot\" style=\"display: flex; flex-direction:column; gap: 1rem;\">\r\n                    </ul>\r\n                </div>\r\n            </div>\r\n            `, {\n            element: `<div></div>`\n        });\n    }\n}));\n"],"names":["RHU","import","module","trace","Error","name","hard","callback","window","require","this","GTFOIcons","Map","img","Image","src","set","graph","GTFOEnemyIcons","GTFOGearIcons","GTFOPackIcons","camera","zoom","x","y","selected","selectedEvents","timeline","addEventListener","e","preventDefault","stopPropagation","ctx","getContext","render","mouse","left","right","origin","old1","button","time","width","timePerPixel","start","end","rect","getBoundingClientRect","clientX","clientY","top","exists","height","deltaY","old","delta","prototype","computed","getComputedStyle","parseInt","w","h","clearRect","player","report","maximum","snapshotSize","gridSize","timePerGrid","Math","floor","ceil","beginPath","moveTo","lineTo","lineWidth","strokeStyle","stroke","translate","save","health","healthMax","infection","healthTimeline","index","length","timestamp","event","percentage","value","round","infectionTimeline","filter","i","stateTimeline","type","has","drawImage","get","damageTimeline","enemyInstanceID","enemy","enemies","playerID","gearName","packsTimeline","x1","x2","temp","fillStyle","fillRect","restore","font","text","metrics","measureText","fillText","seconds","minutes","hours","s","m","toString","padStart","doUpdate","push","updateSnapshot","snapshot","replaceChildren","self","fragment","DocumentFragment","item","lastEvent","timeMergeWindow","reset","document","createElement","style","display","gap","alignItems","color","undefined","closeLastEvent","wrapper","closeDamage","timestr","timeToString","innerHTML","content","append","a","mount","enemiesBtn","click","requestAnimationFrame","navbar","panel","list","goTo","allPlayers","last","doReset","damage","createTextNode","load","clear","spec","image","name1","gear","publicName","name2","packs","pack","Macro"],"version":3,"file":"main.bfd6dab5.js.map"}